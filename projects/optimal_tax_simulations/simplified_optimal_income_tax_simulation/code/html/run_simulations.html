
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>run_simulations</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-07-15"><meta name="DC.source" content="run_simulations.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Compute structural results</a></li><li><a href="#4">Generate plots across elasticities and bias values</a></li><li><a href="#5">Plot optimal tax across different Marg Value of Public Funds from sin tax</a></li><li><a href="#6">Plot income distributions</a></li><li><a href="#7">Display and export results</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> run_simulations()
</pre><pre class="codeinput"><span class="comment">% Run simulations for Allcott, Lockwood, Taubinsky "Regressive Sin Taxes"</span>

clear <span class="string">all</span>;
addpath(genpath(<span class="string">'./functions/'</span>));
addpath(genpath(<span class="string">'../../../../lib/matlab/'</span>));

<span class="keyword">global</span> DATADIR OUTPUT VERBOSE LABORELAST;
DATADIR = <span class="string">'../data'</span>;
OUTPUT = <span class="string">'../output'</span>;
VERBOSE = false; <span class="comment">% report verbose logging to console?</span>

<span class="comment">% global parameters</span>
LABORELAST = 0.33; <span class="comment">% from Chetty ECMA 2012</span>

diaryfile = [OUTPUT <span class="string">'/logfile_new.txt'</span>];
<span class="keyword">if</span> (exist(diaryfile,<span class="string">'file'</span>)), delete(diaryfile); <span class="keyword">end</span>
diary(diaryfile);

USPop = 0.311; <span class="comment">% U.S. adult equivalents, in billions (see text)</span>
</pre><pre class="codeoutput error">Error using diary
../output/logfile_new.txt: File not found.

Error in run_simulations (line 18)
diary(diaryfile);
</pre><h2 id="3">Compute structural results</h2><pre class="codeinput"><span class="comment">% Each specification stores results in a structure r, with</span>
<span class="comment">%   r.spec: name of specification</span>
<span class="comment">%   r.desc: description (e.g., for exported table row titles)</span>
<span class="comment">%   r.prim: model primitives for this specification</span>
<span class="comment">%   r.eqbm: equilibrium values for this specification</span>
<span class="comment">%   r.eqbmOptIncTax: equilibrium when income tax is solved for optimum</span>
<span class="comment">% These results are then stored in a cell called Results.</span>


<span class="comment">% List of specifications to be run in the following simulations</span>
specs = {<span class="keyword">...</span>
    {<span class="string">'baseline'</span>,<span class="string">'Baseline'</span>}<span class="keyword">...</span>
    {<span class="string">'weakRedist'</span>,<span class="string">'Weaker redistributive preferences'</span>}<span class="keyword">...</span>
    {<span class="string">'strongRedist'</span>,<span class="string">'Stronger redistributive preferences'</span>}<span class="keyword">...</span>
    {<span class="string">'inverseOpt'</span>,<span class="string">'Redistributive preferences rationalize U.S. income tax'</span>}<span class="keyword">...</span>
};


<span class="comment">% Loop over specifications to run</span>
specRange = 1:length(specs);

    <span class="keyword">for</span> iR = specRange

        clear <span class="string">r</span>;
        iSpec = specs{iR};
        r.spec = iSpec{1}; <span class="comment">% specification name</span>
        r.desc = [num2str(iR) <span class="string">'. '</span> iSpec{2}]; <span class="comment">% specification description (for Tex table)</span>

        [r.prim,eqbm_US] = calibrate_primitives(r.spec);

        <span class="comment">% Compute optimal income tax</span>
        r.eqbmOptIncTax = compute_optimal_taxes(r.prim,eqbm_US,false);

        Results{iR} = r;

    <span class="keyword">end</span>

    <span class="comment">% Export results</span>

    tab.tableColLabels = {<span class="string">'Existing income tax'</span>,<span class="string">'Optimal income tax'</span>};
    tab.tableCaption = <span class="string">''</span>;
    tab.tableRowLabels = {};
    tab.data = NaN(length(Results),2);
    tab.dataFormat = {<span class="string">'%.2f'</span>};
    tab.tableColumnAlignment = {<span class="string">'l'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>};

    <span class="keyword">for</span> ir = 1:length(Results)

        rr = Results{ir};

        <span class="comment">% Store for export</span>
        tab.tableRowLabels{ir} = rr.desc;
        tab.data(ir,:) = 100.*[rr.ssbTax rr.ssbTaxOptIncTax];

    <span class="keyword">end</span>

    latex = latexTable(tab);

    <span class="keyword">if</span> internalizedHealthCost == 0
        outFile = [OUTPUT <span class="string">'/results_table_PanelA.tex'</span>];
    <span class="keyword">else</span>
        outFile = [OUTPUT <span class="string">'/results_table_PanelB.tex'</span>];
    <span class="keyword">end</span>
    fid = fopen(outFile,<span class="string">'wt'</span>);
    <span class="keyword">for</span> ir=1:size(latex,1)
        fprintf(fid, <span class="string">'%s\n'</span>, latex{ir});
    <span class="keyword">end</span>
    fclose(fid);
</pre><h2 id="4">Generate plots across elasticities and bias values</h2><pre class="codeinput">constBothIdx = 8;

<span class="comment">% double-check</span>
assert(strcmp(Results{constBothIdx}.spec,<span class="string">'constBiasElast'</span>),<span class="string">'wrong index'</span>);


rBaseline = Results{1};
rConstBoth = Results{constBothIdx};

figureSpec = <span class="string">'figure'</span>;
gammaVec = 0:0.01:0.04;

elastBaseline = mean(1./rBaseline.prim.k);

elastVec = [3 elastBaseline 0.5 0.25];
optTaxMat = NaN(length(gammaVec),length(elastVec));
<span class="keyword">for</span> iGamma = 1:length(gammaVec)
    <span class="keyword">for</span> iElast = 1:length(elastVec)
        disp([<span class="string">'(gamma,ssbElast) = '</span> num2str(gammaVec(iGamma)) <span class="string">','</span> num2str(elastVec(iElast)) <span class="string">')'</span>]);
        [prim,eqbm_US] = calibrate_primitives(figureSpec,0,gammaVec(iGamma),elastVec(iElast));
        eqbm = compute_optimal_taxes(prim,eqbm_US);
        optTax = eqbm.soda_tax;
        optTaxMat(iGamma,iElast) = optTax;
    <span class="keyword">end</span>
<span class="keyword">end</span>
plot_comp_statics(gammaVec,elastVec,optTaxMat,mean(rConstBoth.prim.gamma));
</pre><h2 id="5">Plot optimal tax across different Marg Value of Public Funds from sin tax</h2><pre class="codeinput">mvpfSTVec = [0.1 0.5 1 2 3 4 5 7 9];
[prim,eqbm_US] = calibrate_primitives(<span class="string">'baseline'</span>,0);
incTaxFixed = true;

optTaxMVPFs = NaN(length(mvpfSTVec),1);

<span class="keyword">for</span> iMVPF = 1:length(mvpfSTVec)
    eqbm = compute_optimal_taxes(prim,eqbm_US,incTaxFixed,mvpfSTVec(iMVPF));
    optTaxMVPFs(iMVPF) = eqbm.soda_tax;
<span class="keyword">end</span>
plot(mvpfSTVec,100*optTaxMVPFs,<span class="string">'Linewidth'</span>,1)
ylabel(<span class="string">'Optimal SSB tax (cents per ounce)'</span>);
xlabel(<span class="string">'Social value of SSB tax revenues (relative to lump-sum grant)'</span>);
set(gca,<span class="string">'fontsize'</span>,14);
xlim([0; max(mvpfSTVec)]);
ylim([0; ceil(max(100*optTaxMVPFs(:)))]);

hold <span class="string">on</span>;
plot([1 1],[-10; 10],<span class="string">'Linewidth'</span>,0.5,<span class="string">'Color'</span>,<span class="string">'k'</span>);
isPoor = (prim.F &lt; .1);
gHatPoor = trapz(prim.F(isPoor),eqbm.msww_hat(isPoor))/prim.F(sum(isPoor));
plot(gHatPoor*[1 1],[-10; 10],<span class="string">'Linewidth'</span>,0.5,<span class="string">'Color'</span>,<span class="string">'k'</span>);
hold <span class="string">off</span>;

text(1.05,100*optTaxMVPFs(mvpfSTVec==1),<span class="string">'\leftarrow revenues distributed lump-sum'</span>,<span class="string">'FontSize'</span>,12);
gMinTax = interp1(mvpfSTVec,100*optTaxMVPFs,gHatPoor);
text(gHatPoor + .05,gMinTax-.03,<span class="string">'\leftarrow revenues targeted to poorest 10%'</span>,<span class="string">'FontSize'</span>,12);

fname = [OUTPUT <span class="string">'/Figures/across_mvpfs.pdf'</span>];
fig = gcf;
fig.PaperPositionMode = <span class="string">'auto'</span>;
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];

print(fig,fname,<span class="string">'-dpdf'</span>);
close;
</pre><h2 id="6">Plot income distributions</h2><pre class="codeinput">plot(rBaseline.eqbm.income./1000,rBaseline.eqbm.consump./1000,<span class="string">'Marker'</span>,<span class="string">'o'</span>,<span class="string">'Markersize'</span>,5);
hold <span class="string">on</span>;
plot(rBaseline.eqbmOptIncTax.income./1000,rBaseline.eqbmOptIncTax.consump./1000,<span class="string">'Marker'</span>,<span class="string">'d'</span>,<span class="string">'Markersize'</span>,5);
hold <span class="string">off</span>;
ubound = 150;
xlim([0 ubound]);
ylim([0 ubound]);
legend({<span class="string">'US status quo (Piketty et al. 2018)'</span>,<span class="string">'Optimal income tax when allowed to adjust'</span>},<span class="string">'location'</span>,<span class="string">'northwest'</span>);
set(gca,<span class="string">'fontsize'</span>,14);

xlabel(<span class="string">'Pre-tax income ($1000s)'</span>);
ylabel(<span class="string">'Post-tax income ($1000s)'</span>);

fname = [OUTPUT <span class="string">'/Figures/income_tax.pdf'</span>];
fig = gcf;
fig.PaperPositionMode = <span class="string">'auto'</span>;
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];

print(fig,fname,<span class="string">'-dpdf'</span>);
close;
</pre><h2 id="7">Display and export results</h2><pre class="codeinput">save([OUTPUT <span class="string">'/results_workspace.mat'</span>],<span class="string">'Results'</span>);

disp(<span class="string">'Finished.'</span>)
diary <span class="string">off</span>;
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
function run_simulations()
% Run simulations for Allcott, Lockwood, Taubinsky "Regressive Sin Taxes"

clear all;
addpath(genpath('./functions/'));
addpath(genpath('../../../../lib/matlab/'));

global DATADIR OUTPUT VERBOSE LABORELAST; 
DATADIR = '../data'; 
OUTPUT = '../output';
VERBOSE = false; % report verbose logging to console?

% global parameters
LABORELAST = 0.33; % from Chetty ECMA 2012

diaryfile = [OUTPUT '/logfile_new.txt'];
if (exist(diaryfile,'file')), delete(diaryfile); end
diary(diaryfile);

USPop = 0.311; % U.S. adult equivalents, in billions (see text)


%% Compute structural results

% Each specification stores results in a structure r, with 
%   r.spec: name of specification
%   r.desc: description (e.g., for exported table row titles)
%   r.prim: model primitives for this specification
%   r.eqbm: equilibrium values for this specification
%   r.eqbmOptIncTax: equilibrium when income tax is solved for optimum
% These results are then stored in a cell called Results.


% List of specifications to be run in the following simulations
specs = {...
    {'baseline','Baseline'}... 
    {'weakRedist','Weaker redistributive preferences'}... 
    {'strongRedist','Stronger redistributive preferences'}... 
    {'inverseOpt','Redistributive preferences rationalize U.S. income tax'}... 
};


% Loop over specifications to run
specRange = 1:length(specs);
    
    for iR = specRange
        
        clear r;
        iSpec = specs{iR};
        r.spec = iSpec{1}; % specification name
        r.desc = [num2str(iR) '. ' iSpec{2}]; % specification description (for Tex table)
        
        [r.prim,eqbm_US] = calibrate_primitives(r.spec);
        
        % Compute optimal income tax
        r.eqbmOptIncTax = compute_optimal_taxes(r.prim,eqbm_US,false);
        
        Results{iR} = r;
        
    end
    
    % Export results
    
    tab.tableColLabels = {'Existing income tax','Optimal income tax'};
    tab.tableCaption = '';
    tab.tableRowLabels = {};
    tab.data = NaN(length(Results),2);
    tab.dataFormat = {'%.2f'};
    tab.tableColumnAlignment = {'l','c','c'};
    
    for ir = 1:length(Results)
        
        rr = Results{ir};

        % Store for export
        tab.tableRowLabels{ir} = rr.desc;
        tab.data(ir,:) = 100.*[rr.ssbTax rr.ssbTaxOptIncTax];
        
    end
    
    latex = latexTable(tab);
    
    if internalizedHealthCost == 0
        outFile = [OUTPUT '/results_table_PanelA.tex'];
    else
        outFile = [OUTPUT '/results_table_PanelB.tex'];
    end
    fid = fopen(outFile,'wt');
    for ir=1:size(latex,1)
        fprintf(fid, '%s\n', latex{ir});
    end
    fclose(fid);
    



%% Generate plots across elasticities and bias values

constBothIdx = 8;

% double-check
assert(strcmp(Results{constBothIdx}.spec,'constBiasElast'),'wrong index');


rBaseline = Results{1};
rConstBoth = Results{constBothIdx};

figureSpec = 'figure';
gammaVec = 0:0.01:0.04;

elastBaseline = mean(1./rBaseline.prim.k);

elastVec = [3 elastBaseline 0.5 0.25];
optTaxMat = NaN(length(gammaVec),length(elastVec));
for iGamma = 1:length(gammaVec)
    for iElast = 1:length(elastVec)
        disp(['(gamma,ssbElast) = ' num2str(gammaVec(iGamma)) ',' num2str(elastVec(iElast)) ')']);
        [prim,eqbm_US] = calibrate_primitives(figureSpec,0,gammaVec(iGamma),elastVec(iElast));
        eqbm = compute_optimal_taxes(prim,eqbm_US);
        optTax = eqbm.soda_tax;
        optTaxMat(iGamma,iElast) = optTax;
    end
end
plot_comp_statics(gammaVec,elastVec,optTaxMat,mean(rConstBoth.prim.gamma));


%% Plot optimal tax across different Marg Value of Public Funds from sin tax

mvpfSTVec = [0.1 0.5 1 2 3 4 5 7 9];
[prim,eqbm_US] = calibrate_primitives('baseline',0);
incTaxFixed = true;

optTaxMVPFs = NaN(length(mvpfSTVec),1);

for iMVPF = 1:length(mvpfSTVec)
    eqbm = compute_optimal_taxes(prim,eqbm_US,incTaxFixed,mvpfSTVec(iMVPF));
    optTaxMVPFs(iMVPF) = eqbm.soda_tax;
end
plot(mvpfSTVec,100*optTaxMVPFs,'Linewidth',1)
ylabel('Optimal SSB tax (cents per ounce)');
xlabel('Social value of SSB tax revenues (relative to lump-sum grant)');
set(gca,'fontsize',14);
xlim([0; max(mvpfSTVec)]);
ylim([0; ceil(max(100*optTaxMVPFs(:)))]);

hold on;
plot([1 1],[-10; 10],'Linewidth',0.5,'Color','k');
isPoor = (prim.F < .1);
gHatPoor = trapz(prim.F(isPoor),eqbm.msww_hat(isPoor))/prim.F(sum(isPoor));
plot(gHatPoor*[1 1],[-10; 10],'Linewidth',0.5,'Color','k');
hold off;

text(1.05,100*optTaxMVPFs(mvpfSTVec==1),'\leftarrow revenues distributed lump-sum','FontSize',12);
gMinTax = interp1(mvpfSTVec,100*optTaxMVPFs,gHatPoor);
text(gHatPoor + .05,gMinTax-.03,'\leftarrow revenues targeted to poorest 10%','FontSize',12);

fname = [OUTPUT '/Figures/across_mvpfs.pdf'];
fig = gcf;
fig.PaperPositionMode = 'auto';
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];

print(fig,fname,'-dpdf');
close;



%% Plot income distributions
plot(rBaseline.eqbm.income./1000,rBaseline.eqbm.consump./1000,'Marker','o','Markersize',5);
hold on;
plot(rBaseline.eqbmOptIncTax.income./1000,rBaseline.eqbmOptIncTax.consump./1000,'Marker','d','Markersize',5);
hold off;
ubound = 150;
xlim([0 ubound]);
ylim([0 ubound]);
legend({'US status quo (Piketty et al. 2018)','Optimal income tax when allowed to adjust'},'location','northwest');
set(gca,'fontsize',14);

xlabel('Pre-tax income ($1000s)');
ylabel('Post-tax income ($1000s)');

fname = [OUTPUT '/Figures/income_tax.pdf'];
fig = gcf;
fig.PaperPositionMode = 'auto';
fig_pos = fig.PaperPosition;
fig.PaperSize = [fig_pos(3) fig_pos(4)];

print(fig,fname,'-dpdf');
close;


%% Display and export results

save([OUTPUT '/results_workspace.mat'],'Results');

disp('Finished.')
diary off;

end

##### SOURCE END #####
--></body></html>